import { sql } from "drizzle-orm";
import { index, uniqueIndex, jsonb, pgTable, timestamp, varchar, serial, boolean, text, date, time, integer, numeric, pgEnum } from "drizzle-orm/pg-core";
import { users } from "./auth-session";

export const bookingSourceEnum = pgEnum("booking_source", ["member_request", "staff_manual", "trackman_import", "trackman_webhook"]);
export const paymentMethodEnum = pgEnum("payment_method", ["guest_pass", "credit_card", "unpaid", "waived"]);
export const participantTypeEnum = pgEnum("participant_type", ["owner", "member", "guest"]);
export const participantPaymentStatusEnum = pgEnum("participant_payment_status", ["pending", "paid", "waived"]);

// Resources table - bookable resources
export const resources = pgTable("resources", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  type: varchar("type").notNull(),
  description: text("description"),
  capacity: integer("capacity").default(1),
  createdAt: timestamp("created_at").defaultNow(),
});

// Availability blocks table - blocked time slots
// FK constraint: resource_id references resources.id with CASCADE delete
export const availabilityBlocks = pgTable("availability_blocks", {
  id: serial("id").primaryKey(),
  resourceId: integer("resource_id").references(() => resources.id, { onDelete: 'cascade' }),
  blockDate: date("block_date").notNull(),
  startTime: time("start_time").notNull(),
  endTime: time("end_time").notNull(),
  blockType: varchar("block_type").notNull(),
  notes: text("notes"),
  createdBy: varchar("created_by"),
  createdAt: timestamp("created_at").defaultNow(),
  closureId: integer("closure_id"),
  eventId: integer("event_id"),
  wellnessClassId: integer("wellness_class_id"),
}, (table) => [
  uniqueIndex("availability_blocks_resource_unique_idx").on(
    table.resourceId, table.blockDate, table.startTime, table.endTime, table.closureId
  )
]);

// Booking requests table - pending booking requests
// FK constraints: user_id references users.id (SET NULL on delete to preserve history)
//                 resource_id references resources.id (SET NULL on delete to preserve booking history)
export const bookingRequests = pgTable("booking_requests", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: 'set null' }),
  userEmail: varchar("user_email").notNull(),
  userName: varchar("user_name"),
  resourceId: integer("resource_id").references(() => resources.id, { onDelete: 'set null' }),
  resourcePreference: varchar("resource_preference"),
  requestDate: date("request_date").notNull(),
  startTime: time("start_time").notNull(),
  durationMinutes: integer("duration_minutes").notNull(),
  endTime: time("end_time").notNull(),
  notes: text("notes"),
  status: varchar("status").default("pending"),
  staffNotes: text("staff_notes"),
  suggestedTime: time("suggested_time"),
  reviewedBy: varchar("reviewed_by"),
  reviewedAt: timestamp("reviewed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  calendarEventId: varchar("calendar_event_id"),
  rescheduleBookingId: integer("reschedule_booking_id"),
  trackmanBookingId: varchar("trackman_booking_id"),
  originalBookedDate: timestamp("original_booked_date"),
  guestCount: integer("guest_count").default(0),
  trackmanPlayerCount: integer("trackman_player_count"),
  sessionId: integer("session_id"),
  declaredPlayerCount: integer("declared_player_count"),
  finalPlayerCount: integer("final_player_count"),
  originalStartTime: time("original_start_time"),
  originalEndTime: time("original_end_time"),
  originalResourceId: integer("original_resource_id"),
  memberNotes: varchar("member_notes", { length: 280 }),
  reconciliationStatus: varchar("reconciliation_status"),
  reconciliationNotes: text("reconciliation_notes"),
  reconciledBy: varchar("reconciled_by"),
  reconciledAt: timestamp("reconciled_at"),
  archivedAt: timestamp("archived_at"),
  archivedBy: varchar("archived_by"),
  // Guardian consent fields for minor bookings (under 18)
  guardianName: varchar("guardian_name"),
  guardianRelationship: varchar("guardian_relationship"),
  guardianPhone: varchar("guardian_phone"),
  guardianConsentAt: timestamp("guardian_consent_at"),
  stripeInvoiceId: varchar("stripe_invoice_id"),
  // Trackman external ID linking - UUID generated by Trackman when booking is created
  trackmanExternalId: varchar("trackman_external_id"),
  // Flag for unmatched bookings created from Trackman webhooks without member identification
  isUnmatched: boolean("is_unmatched").default(false),
  // Customer notes from Trackman for staff reference when matching unmatched bookings
  trackmanCustomerNotes: text("trackman_customer_notes"),
  // Pre-declared participant info from member during booking request
  requestParticipants: jsonb("request_participants"),
  // Flag indicating if booking was auto-linked to existing request (vs manually linked by staff)
  wasAutoLinked: boolean("was_auto_linked").default(false),
  // Origin tracking - who originally created this booking
  origin: varchar("origin"), // 'member_request' | 'staff_manual' | 'trackman_webhook' | 'trackman_import'
  // Last sync source - which system last updated this booking
  lastSyncSource: varchar("last_sync_source"), // 'trackman_webhook' | 'trackman_import' | 'staff' | 'member'
  // Timestamp of last Trackman data sync (from webhook or import)
  lastTrackmanSyncAt: timestamp("last_trackman_sync_at"),
  // Flag for private event bookings (removes from unmatched queue without member assignment)
  isEvent: boolean("is_event").default(false),
  // Flag indicating Trackman player count is higher than app request's declared player count
  playerCountMismatch: boolean("player_count_mismatch").default(false),
  // Optimistic locking version for roster edits to prevent concurrent overwrites
  rosterVersion: integer("roster_version").default(0),
  // Link to facility closure when booking is marked as private event
  closureId: integer("closure_id"),
  cancellationPendingAt: timestamp("cancellation_pending_at"),
}, (table) => [
  uniqueIndex("idx_booking_requests_trackman_booking_id").on(table.trackmanBookingId),
  uniqueIndex("booking_requests_trackman_external_id_idx").on(table.trackmanExternalId),
  index("booking_requests_session_idx").on(table.sessionId),
  index("booking_requests_date_resource_idx").on(table.requestDate, table.resourceId),
  index("booking_requests_user_id_idx").on(table.userId),
  index("booking_requests_unmatched_idx").on(table.isUnmatched),
]);

// Facility closures table - scheduled closures
export const facilityClosures = pgTable("facility_closures", {
  id: serial("id").primaryKey(),
  title: varchar("title").notNull(),
  reason: text("reason"),
  memberNotice: text("member_notice"),
  notes: text("notes"),
  noticeType: varchar("notice_type"),
  startDate: date("start_date").notNull(),
  startTime: time("start_time"),
  endDate: date("end_date").notNull(),
  endTime: time("end_time"),
  affectedAreas: varchar("affected_areas"),
  notifyMembers: boolean("notify_members").default(false),
  isActive: boolean("is_active").default(true),
  needsReview: boolean("needs_review").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  createdBy: varchar("created_by"),
  googleCalendarId: varchar("google_calendar_id"),
  conferenceCalendarId: varchar("conference_calendar_id"),
  internalCalendarId: varchar("internal_calendar_id"),
});

// Trackman unmatched bookings - historical bookings that couldn't be matched to members
export const trackmanUnmatchedBookings = pgTable("trackman_unmatched_bookings", {
  id: serial("id").primaryKey(),
  trackmanBookingId: varchar("trackman_booking_id").notNull(),
  userName: varchar("user_name"),
  originalEmail: varchar("original_email"),
  bookingDate: date("booking_date").notNull(),
  startTime: time("start_time").notNull(),
  endTime: time("end_time").notNull(),
  durationMinutes: integer("duration_minutes"),
  status: varchar("status"),
  bayNumber: varchar("bay_number"),
  playerCount: integer("player_count"),
  notes: text("notes"),
  matchAttemptReason: text("match_attempt_reason"),
  resolvedEmail: varchar("resolved_email"),
  resolvedAt: timestamp("resolved_at"),
  resolvedBy: varchar("resolved_by"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Trackman import runs - track import history
export const trackmanImportRuns = pgTable("trackman_import_runs", {
  id: serial("id").primaryKey(),
  filename: varchar("filename").notNull(),
  totalRows: integer("total_rows").notNull(),
  matchedRows: integer("matched_rows").notNull(),
  unmatchedRows: integer("unmatched_rows").notNull(),
  skippedRows: integer("skipped_rows").notNull(),
  importedBy: varchar("imported_by"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Tours table - scheduled tours synced from HubSpot Meetings (legacy: Google Calendar)
export const tours = pgTable("tours", {
  id: serial("id").primaryKey(),
  googleCalendarId: varchar("google_calendar_id").unique(),
  hubspotMeetingId: varchar("hubspot_meeting_id").unique(),
  title: varchar("title").notNull(),
  guestName: varchar("guest_name"),
  guestEmail: varchar("guest_email"),
  guestPhone: varchar("guest_phone"),
  tourDate: date("tour_date").notNull(),
  startTime: time("start_time").notNull(),
  endTime: time("end_time"),
  notes: text("notes"),
  status: varchar("status").default("scheduled"),
  checkedInAt: timestamp("checked_in_at"),
  checkedInBy: varchar("checked_in_by"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Closure reasons table - configurable dropdown options for closure reason
export const closureReasons = pgTable("closure_reasons", {
  id: serial("id").primaryKey(),
  label: varchar("label", { length: 255 }).notNull().unique(),
  sortOrder: integer("sort_order").default(100),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

export type ClosureReason = typeof closureReasons.$inferSelect;
export type InsertClosureReason = typeof closureReasons.$inferInsert;

export type Tour = typeof tours.$inferSelect;
export type InsertTour = typeof tours.$inferInsert;
export type TrackmanUnmatchedBooking = typeof trackmanUnmatchedBookings.$inferSelect;
export type InsertTrackmanUnmatchedBooking = typeof trackmanUnmatchedBookings.$inferInsert;
export type TrackmanImportRun = typeof trackmanImportRuns.$inferSelect;

// ============================================================================
// Multi-Member Booking System Tables (Phase 1)
// ============================================================================

// Booking sessions table - central hub linking bookings to Trackman and participants
// FK constraint: resource_id references resources.id (RESTRICT to prevent accidental deletion of resources with sessions)
export const bookingSessions = pgTable("booking_sessions", {
  id: serial("id").primaryKey(),
  trackmanBookingId: varchar("trackman_booking_id").unique(),
  resourceId: integer("resource_id").notNull().references(() => resources.id, { onDelete: 'restrict' }),
  sessionDate: date("session_date").notNull(),
  startTime: time("start_time").notNull(),
  endTime: time("end_time").notNull(),
  source: bookingSourceEnum("source").default("member_request"),
  createdBy: varchar("created_by"),
  needsReview: boolean("needs_review").default(false),
  reviewReason: text("review_reason"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("booking_sessions_resource_date_idx").on(table.resourceId, table.sessionDate),
  index("booking_sessions_trackman_idx").on(table.trackmanBookingId),
]);

// Guests table - persistent guest tracking across bookings
export const guests = pgTable("guests", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  email: varchar("email"),
  phone: varchar("phone"),
  createdByMemberId: varchar("created_by_member_id"),
  lastVisitDate: date("last_visit_date"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("guests_email_idx").on(table.email),
  index("guests_created_by_idx").on(table.createdByMemberId),
]);

// Usage ledger table - tracks per-member time and fees with tier snapshot
export const usageLedger = pgTable("usage_ledger", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull(),
  memberId: varchar("member_id"),
  minutesCharged: integer("minutes_charged").notNull().default(0),
  overageFee: numeric("overage_fee", { precision: 10, scale: 2 }).default("0.00"),
  guestFee: numeric("guest_fee", { precision: 10, scale: 2 }).default("0.00"),
  tierAtBooking: varchar("tier_at_booking"),
  paymentMethod: paymentMethodEnum("payment_method").default("unpaid"),
  source: bookingSourceEnum("source").default("member_request"),
  stripePaymentIntentId: varchar("stripe_payment_intent_id"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("usage_ledger_session_idx").on(table.sessionId),
  index("usage_ledger_member_idx").on(table.memberId),
  index("usage_ledger_stripe_payment_intent_idx").on(table.stripePaymentIntentId),
]);

// Booking participants table - unified table for all participants (replaces booking_members/booking_guests)
export const bookingParticipants = pgTable("booking_participants", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull(),
  userId: varchar("user_id"),
  guestId: integer("guest_id"),
  participantType: participantTypeEnum("participant_type").notNull(),
  displayName: varchar("display_name").notNull(),
  slotDuration: integer("slot_duration"),
  paymentStatus: participantPaymentStatusEnum("payment_status").default("pending"),
  trackmanPlayerRowId: varchar("trackman_player_row_id"),
  inviteStatus: varchar("invite_status").default("accepted"),
  invitedAt: timestamp("invited_at"),
  respondedAt: timestamp("responded_at"),
  inviteExpiresAt: timestamp("invite_expires_at"),
  expiredReason: varchar("expired_reason"),
  stripePaymentIntentId: varchar("stripe_payment_intent_id"),
  paidAt: timestamp("paid_at"),
  usedGuestPass: boolean("used_guest_pass"),
  waiverReviewedAt: timestamp("waiver_reviewed_at"),
  cachedFeeCents: integer("cached_fee_cents"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("booking_participants_session_idx").on(table.sessionId),
  index("booking_participants_user_idx").on(table.userId),
  index("booking_participants_guest_idx").on(table.guestId),
]);

export type BookingSession = typeof bookingSessions.$inferSelect;
export type InsertBookingSession = typeof bookingSessions.$inferInsert;
export type Guest = typeof guests.$inferSelect;
export type InsertGuest = typeof guests.$inferInsert;
export type UsageLedger = typeof usageLedger.$inferSelect;
export type InsertUsageLedger = typeof usageLedger.$inferInsert;
export type BookingParticipant = typeof bookingParticipants.$inferSelect;
export type InsertBookingParticipant = typeof bookingParticipants.$inferInsert;
// Dismissed HubSpot meetings table - tracks HubSpot meetings that were dismissed/ignored
export const dismissedHubspotMeetings = pgTable("dismissed_hubspot_meetings", {
  id: serial("id").primaryKey(),
  hubspotMeetingId: varchar("hubspot_meeting_id").notNull().unique(),
  dismissedBy: varchar("dismissed_by"),
  dismissedAt: timestamp("dismissed_at").notNull().defaultNow(),
  notes: text("notes"),
});

export type DismissedHubspotMeeting = typeof dismissedHubspotMeetings.$inferSelect;
export type InsertDismissedHubspotMeeting = typeof dismissedHubspotMeetings.$inferInsert;

export const trackmanWebhookEventTypeEnum = pgEnum("trackman_webhook_event_type", [
  "user_update",
  "booking_update",
  "purchase_update",
  "purchase_paid",
  "unknown"
]);

export const trackmanBaySlotStatusEnum = pgEnum("trackman_bay_slot_status", [
  "booked",
  "cancelled",
  "completed"
]);

export const trackmanWebhookEvents = pgTable("trackman_webhook_events", {
  id: serial("id").primaryKey(),
  eventType: trackmanWebhookEventTypeEnum("event_type").notNull(),
  trackmanBookingId: varchar("trackman_booking_id"),
  trackmanUserId: varchar("trackman_user_id"),
  payload: jsonb("payload").notNull(),
  processedAt: timestamp("processed_at"),
  processingError: text("processing_error"),
  matchedBookingId: integer("matched_booking_id"),
  matchedUserId: varchar("matched_user_id"),
  dedupKey: varchar("dedup_key"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("trackman_webhook_events_type_idx").on(table.eventType),
  index("trackman_webhook_events_trackman_booking_idx").on(table.trackmanBookingId),
  index("trackman_webhook_events_created_idx").on(table.createdAt),
  uniqueIndex("trackman_webhook_events_dedup_key_idx").on(table.dedupKey),
]);

export const trackmanBaySlots = pgTable("trackman_bay_slots", {
  id: serial("id").primaryKey(),
  resourceId: integer("resource_id").notNull().references(() => resources.id, { onDelete: 'cascade' }),
  slotDate: date("slot_date").notNull(),
  startTime: time("start_time").notNull(),
  endTime: time("end_time").notNull(),
  status: trackmanBaySlotStatusEnum("status").default("booked"),
  trackmanBookingId: varchar("trackman_booking_id"),
  customerEmail: varchar("customer_email"),
  customerName: varchar("customer_name"),
  playerCount: integer("player_count").default(1),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("trackman_bay_slots_resource_date_idx").on(table.resourceId, table.slotDate),
  index("trackman_bay_slots_trackman_booking_idx").on(table.trackmanBookingId),
  uniqueIndex("trackman_bay_slots_unique_idx").on(table.resourceId, table.slotDate, table.startTime, table.trackmanBookingId),
]);

export type TrackmanWebhookEvent = typeof trackmanWebhookEvents.$inferSelect;
export type InsertTrackmanWebhookEvent = typeof trackmanWebhookEvents.$inferInsert;
export type TrackmanBaySlot = typeof trackmanBaySlots.$inferSelect;
export type InsertTrackmanBaySlot = typeof trackmanBaySlots.$inferInsert;
